#!/usr/bin/env node
"use strict";

exports.command = {
    description: 'Import a UFO to a master'
  , arguments: '<ufo> <[project]/master>'
};
if (require.main === module) {

var requirejs = require('requirejs')
  , configure = requirejs('node-config')
  , path = require('path')
  , program = require('commander')
    // expect require.main.filename to be path/to/root/bin/<command>
    // thus path/to/root is the root directory
  , rootDir = path.dirname(__dirname)
  ;

configure(requirejs);

program._name = path.basename(process.argv[1]).replace('-', ' ');
program.arguments(exports.command.arguments)
    .description(exports.command.description);

requirejs([
    'Atem-MOM/errors'
  , 'Atem-IO/io/static'
  , 'Atem-MOM/project/Project'
], function (
    errors
  , io
  , Project
) {
    var CommandLineError = errors.Error;//errors.CommandLine;

    function main(sourceUFODir, projectMaster) {
        // We should have a module or something to set this up.
        // This is not yet the final way. Also, write protection
        // is missing!
        var cpsLibIoMounts = [
            // add more of these configuration objects to include more
            // libraries each object yields in a call to MountingIO.mount
            // the keys correlate with the argument names of MountingIO
            // however, Project does some augmentation.
            {
            //  io: io// not needed here, because it is the same io
                mountPoint: 'lib/MOM' // we will need more flexibility here
              , pathOffset: rootDir + '/lib/cpsLib'
              , allowAboveRoot: true
            }
        ];
        var pm = projectMaster.split('/')
        // var pm = parseArgs.projectMaster(io, targetMaster);
          , projectDir = pm[0]
          , masterName = pm[1]
          ;
        var project = new Project(io, projectDir, undefined, cpsLibIoMounts);

        project.load();
        project.import(false, masterName, sourceUFODir, program.glyphs);
        project.save();
    }

    program.action(main);
    program.option('-g, --glyphs <glyphs>', 'A comma-separated of glyph names to import',
        function(value) {
            var glyphNames = value.split(',')
                             .map(function(item){ return item.trim(); })
                             .filter(function(item){ return !!item.length; });

            if(!glyphNames.length)
                throw new CommandLineError('The value of option "glyphs" '
                                          + 'did not produce a list of names, value was: "'
                                          + value + '" expected was a comma separated list '
                                          + 'of glyph names');
            return glyphNames;
        });
    program.parse(process.argv);
});

}
